package guru.springframework.sfgpetclinic.model;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import java.io.Serializable;

/**
 * Created by jt on 7/18/18.
 * LEZIONE 146
 * ANNOTAZIONE MappedSuperclass STABILISCE
 * CHE QUESTA E' UNA CLASSE BASE PER JPA
 * PER SEGNALARE A JPA CHE DA QUESTA
 * CLASSE NE DERIVERANNO ALTRE CHE SARANNO
 * MAPPARE SUL DATABASE
 * HA QUINDI UN VALORE DI IDENTIFICAZIONE ID
 * CHE SARA COMUNE A TUTTE LE CLASSI FIGLIE
 */
// LEZIONE 168 Aggiungo annotazioni lombok
@Getter
@Setter
@NoArgsConstructor
// LEZIONE 168 ANNOTAZIONE BUILDER OWNER
@AllArgsConstructor
// LEZIONE 168 ANNOTAZIONE BUILDER OWNER
// LEZIONE 168 Aggiungo annotazioni lombok
@MappedSuperclass
public class BaseEntity implements Serializable {

    // LEZIONE 146
    // ANNOTAZIONE Id DICE A JPA
    // CHE QUELLO CHE SEGUE E' IL VALORE ID
    // ANNOTAZIONE GeneratedValue
    // SIGNIFICA CHE AD OGNI RECORD SARA'
    // GENERATO IN AUTOMATICO UN VALORE
    // IN SEQUENZA
    // STRATEGY=GenerationType.IDENTITY
    // SPECIFICA COME IL VALORE DEVE ESSERE
    // UNIVOCO
    // TUTTO QUESTO E' SPECIFICATO
    // TRAMITE javax.persistence di JPA
    // QUINDI IL VALORE GENERATO SARA' UN
    // VALORE PUBLICO ENUMERATIVO
    // I VALORI POSSIBILI DI GENERATIONNTYPE
    // SONO TABELLA SEQUENZA IDENTITY AUTO
    // 1-TABELLA SIGNIFICA CHE AVREMO UNA TABELLA
    // DI DATABASE CON UN VALORE DI SEQUENZA
    // CHE POTRA' ESSERE USATO PER SAPERE
    // IL VALORE MASSIMO O IL SUCCESSIVO DELLA SEQUENZA

    // 2-SEQUENCE I DB HANNO I GENERATORI DI SEUQENZE
    // A CUI SI PUO CHIEDERE IL PROSSIMO NUMERO
    // DI SEQUENZA. BUONA SCELA MA SIGNIFICA
    // CHE IL FORNITORE DEL DB LO DEVE PREVEDERE

    // 3-IDENTITY VERRA' INSETITO NEL DB
    // CON IL VALORE DI ID FORNITO
    // STIAMO PIANIFICANDO DI USARE UNA COLONNA
    // GENERATA AUTOMATICAMENTE . MOLTO USATA
    // IN MYSQL PER CUI VIENE SCELTO QUESTO
    // LO SVANTAGGIO E' QUELLO LEGARE
    // L'APPLICAZIONE AL DB SPECIFICO

    // 4-AUTO SIGMIFICA CHE NE SCEGLIEREMO UNO
    // E CONSENTIREMO AD HIBERNATE DI ESAMINARE IL DB
    // SOTTOSTANTE E DETERMINARE UNA STRATEGIA
    // DA UTILIZZARE , QUESTA ULTIMA OPZIONE
    // PUO' DARE QUALCHE PROBLEMI CON
    // RISULTATI IMPREVEDIBILE
    //
    // IN OGNI CASO L'ESEMPIO E' ORIENTATO A MySql
    // COME DB E USIAMO UN CAMPO INCREMENTATO
    // AUTOMATICAMENTE AD OGNI RECORD INSERITO
    // MySql GESTITA' LA COSA FORNENDO IL PROSSIMO
    // NUMERO IN SEQUENZA
    // VERRA' USATO ANCHE H2 COME DATABASE IN MEMORIA
    // CHE E' COMUNEMENTE UTILIZZATO PER TESTARE
    // L'APPLICAZIONE SPRING MENTRE IN PRODUZIONE UTILIZZERA
    // IL DATABASE EFFETTIVO SOTTOSTANTE
    // ANCHE H2 FORNISCE LA GESTIONE AUTOMATICA
    // DELLE SEQUENZE E QUINDI C'E' UN ELEVATA
    // COMPATIBILITA' TRA LA VERSIONE IN MEMORIA H2
    // E QUELLA SUL DB MySql VISTO CHE USANO LA STESSA SINTASSI
    // E TUTTO GRAZIE ALL'ANNOTAZIONE MappedSuperclass
    // LE CLASSE CHE EREDETINAO DALLE CLASSI CHE
    // L'ANNOTAZIONE DEVONO SPECIFICARE ALCUNE COSE
    // ALTRIMENTI AVREMO DEGLI ERRORI IN FASE DU BUILD
    // O ALL'AVVIO DI SPRING
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    public boolean isNew() {
        return this.id == null;
    }
}
